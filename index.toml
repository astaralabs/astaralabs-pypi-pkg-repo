mtime = 1694856100
[[pkgs]]
type = "github"
distrib = "beehive"
package = "beehive-0.2.0-py3-none-any"
ext = "whl"
sha256 = "434ccf3cce6997edd2e13985438439e2e34233cc447c0be9ecebe879890698b8"
url = "https://api.github.com/repos/astaralabs/astaralabs-pypi-pkg-repo/releases/assets/119752023"

[pkgs.meta]
name = "beehive"
version = "0.2.0"
filetype = "bdist_wheel"
pyversion = "py3"
metadata_version = "2.1"
summary = ""
home_page = ""
author = "astara labs"
author_email = "dev@astaralabs.com"
maintainer = ""
maintainer_email = ""
license = ""
description = "# beehive\n\nBeehive is a library aimed at characterizing a territory with indicators. It works by dividing a territory defined by a polygon into a set of hexagons (with the [H3 hexagonal grid](https://h3geo.org/) as the base), then computing each of the indicators for each of the hexagons.\n\nIt includes tools to compute similarities between different hexagons within the territory and create distance matrix of them.\n\nTools to export the territory and the characterized hexagons to GeoJSON are also included.\n\n## Installation\n\nThe package is hosted in the Astaralabs PyPi, so you will need to add the repository as a source before installing\n\n```bash\n# set our PyPi repository as a source in Poetry\npoetry source add --secondary astaralabs-pypi https://astaralabs.github.io/astaralabs-pypi-pkg-repo/\n\n## If using poetry 1.5 or above\n# poetry source add --priority=explicit astaralabs-pypi https://astaralabs.github.io/astaralabs-pypi-pkg-repo/\n\npoetry add --source=astaralabs-pypi beehive\n\n# Alternatively, with pip\n\npip install -i https://astaralabs.github.io/astaralabs-pypi-pkg-repo/ beehive\n```\n\n## Key concepts\n\nA **Territory** can be any land area defined by one or more polygons. It can be of any size.\n\nA Territory has a tessellation, which is a complete covering of it formed of **Hexagons**. Each Hexagon is defined by its [H3 index](https://h3geo.org/docs/library/terminology) (a unique unsigned 64 bit integer, represented as a hexadecimal string) but has also a `geometry` property defined by the [Shapely Polygon](https://shapely.readthedocs.io/en/stable/reference/shapely.Polygon.html#shapely.Polygon) representing its coordinates.\n\nThe size (called resolution) of the hexagons can be specified from 0 (bigger hexagons) to 15 (smaller hexagons). For a table comparing average hexagon areas for each resolution, check [H3 documentation](https://h3geo.org/docs/core-library/restable/#average-area-in-km2).\n\nWhen creating a territory, some **Indicators** are usually defined. They will be computed for each of the hexagons in the tessellation, and thus an Hexagon object will have a set of Indicators that define _how_ the Hexagon looks like, or characterizes it.\n\nAn Indicator can be anything that defines the land: from the average temperature or precipitations, to the surface of green zones, forests, or the length of the streets within it.\n\nThe library currently includes the following set of pre-defined indicators:\n\n- building_area: percentage of area which is covered by buildings of any kind. The data is obtained from OSM.\n- park_area: percentage of area which is covered by parks. Data obtained from OSM.\n- road_density: total sum of road lanes, in meters, inside the hexagon, divided by total area in squared meters of the hexagon. Data is also obtained from OSM.\n- precipitation_sum: total sum of precipitations (rain or snow) in the last year, measured in mm. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- rain_sum: total sum if rain precipitations in the last year, measured in mm. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- snowfall_sum: total sum of snow precipitations in the last year, measured in mm. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- temperature_2m_max: mean of the maximum daily temperatures at 2m above the ground in the last year, measured in Celsius. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- temperature_2m_min: mean of the minimum daily temperatures at 2m above the ground in the last year, measured in Celsius. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- temperature_2m_mean: mean of the mean daily temperatures at 2m above the ground in the last year, measured in Celsius. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- winddirection_10m_dominant: mean of the dominant daily wind directions, measured at 10 meters above the ground in the last year. Measured in °. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- windgusts_10_max: mean of the maximum wind gusts each day, measured at 10 meters above the ground, in km/h, in the last year. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- windspeed_10_max: mean of the maximum wind speed each day, measured at 10 meters above the ground, in km/h, in the last year. The data is obtained from [Open Meteo](https://open-meteo.com/)\n\nIt is possible to use user-defined indicators. Any function that takes a shapely `Polygon` and returns an `Indicator` instance can be used.\n\n## Usage\n\nCreating a territory from a GeoJSON Polygon Feature.\n\n```Python\nfrom shapely.geometry import shape\nfrom beehive.territory import create_territory\n\nterritory_geojson = {\n    \"type\": \"Feature\",\n    \"properties\": {\n        \"place_id\": 307814314,\n        \"osm_type\": \"relation\",\n        \"osm_id\": 349469,\n        \"display_name\": \"Usera, Madrid, Comunidad de Madrid, España\"\n    },\n    \"bbox\": [-3.7208913, 40.3614413, -3.6817178, 40.395234],\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [\n                [-3.7208913, 40.3655479],\n               ...\n            ]\n        ]\n    }\n}\n\npolygon = shape(territory_geojson[\"geometry\"])\nterritory = create_territory(\n    name=\"Usera, Madrid\",\n    geometry=polygon,\n    indicators=[\"road_density\", \"building_area\", \"park_area\", \"precipitation_sum\"],\n    hex_resolution=8,\n)\n```\n\nCalculate the distance correlation matrix for each Hexagon:\n\n```Python\nfrom beehive.distance import calculate_matrix\n\nmatrix = calculate_matrix(territory.tessellation, metric=\"correlation\")\n```\n\nUsing custom indicators.\n\n```Python\nfrom beehive.model import Polygon, Indicator\nimport random\n\n# The model.Polygon is just a Shapely Polygon re-exported from our module\n\ndef my_random_indicator(polygon: Polygon) -> Indicator:\n    return Indicator(type=\"rand\", name=\"Random\", unit=\"none\", value=random.random())\n\nterritory = create_territory(\n    name=\"Usera, Madrid\",\n    geometry=polygon,\n    custom_indicators=[my_random_indicator],\n    hex_resolution=8,\n)\n```\n\n## API\n\nThe following modules are defined in the package\n\n### beehive.model\n\nIncludes classes for main concepts like Territory, Hexagon or Indicator.\n\n#### Indicator\n\nProperties:\n\n- _type_: `str`. type defining the indicator. E.g. road_density.\n- _name_: `str`. readable name of the indicator. E.g. Road length.\n- _unit_: `str`. unit in which the indicator is measured. E.g. m (meters).\n- _value_: `float`. the value of the indicator.\n\nMethods:\n\n- to_dict() -> dict: returns dict representation of the indicator properties.\n\n#### Hexagon\n\nProperties:\n\n- _id_: `str`. Unique id defining the Hexagon. In fact, a H3 index determining the exact Hexagon in the H3 hex grid.\n- _geometry_: `shapely.Polygon`. Polygon defining the boundaries of the hexagon.\n- _indicators_: `set[Indicator]`. Set containing all the Indicators defined for the Hexagon.\n- _ordered_indicators_: `list[Indicator]`. The previous indicators, but as a list and sorted alphabetically by their `type`.\n\nMethods:\n\n- `to_geojson_dict() -> dict`: returns a dict with the GeoJSON representation of the Hexagon. Indicators, and id are included as `properties`.\n\n#### Territory\n\nProperties:\n\n- _id_: `str`. Unique id asigned to the territory.\n- _name_: `str`. Name of the territory. E.g. \"Norte de Madrid\".\n- _geometry_: `shapely.Polygon | shapely.MultiPolygon`. Polygon defining the boundaries of the territory.\n- _tessellation_: `list[Hexagon]`. List of Hexagons covering the territory geometry.\n\nMethods:\n\n- `to_geojson_dict() -> dict`: returns a dict with the GeoJSON representation of the Territory. Name and id are included as `properties`.\n\n- `tessellation_to_geojson_dict() -> dict`: returns a dict with the GeoJSON FeatureCollection of the Hexagons that form the territory tessellation.\n\n### beehive.territory\n\nIncludes functions to create both single Hexagon or Territory with an hexagonal tessellation, with specified Indicators.\n\n- `create_hexagon(id: str, polygon: shapely.Polygon, indicators: list[str]) -> model.Hexagon`: creates an Hexagon object for the given polygon and with the specified indicators.\n- `create_territory(name: str, polygon: shapely.Polygon, indicators: list[str], hex_resolution: int = 10) -> model.Territory`: creates the hexagonal tessellation with the specified resolution, then computes all the indicators for each hexagon, and creates the territory holding them, and returns it.\n\n### beehive.distance\n\nFunctions to compute distance between Hexagons for a territory, based on the characterization given by their indicators.\n\n- `calculate_matrix(hexagons: list[model.Hexagon], metric= \"correlation\") -> list[float]`: returns the condensed distance matrix of the given hexagons, which is an 1-array representation of the matrix distance. As specified by the [Scipy documentation](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html#scipy.spatial.distance.pdist), \"For each i and j (where i< j < m), where m is the number of original observations. The metric dist(u=X[i], v=X[j]) is computed and stored in entry m _ i + j - ((i + 2) _ (i + 1)) / 2\".\n\n## TODO / Roadmap\n\n- Add more indicators.\n\n## Development\n\n### Dependencies\n\nYou will need to have Poetry [installed](https://python-poetry.org/docs/#installation).\n\nThen, to install all the dependencies, run `poetry install`.\n\n### Testing, linting, formatting...\n\nRun the tests with `poetry run pytest`.\n\nFor running the linter with autofixing: `poetry run ruff .`. (Ruff configuration is located in [pyproject.toml](pyproject.toml)).\n\nBlack can be used to format the files with `poetry run black .` (Black configuration is located in [pyproject.toml](pyproject.toml)).\n\n### Releases\n\nAs of today, GitHub Package Repository does not support Python packages. For that reason, we have created a [private PyPi repository](https://github.com/astaralabs/astaralabs-pypi-pkg-repo) on top of GitHub Pages using [this tool](https://github.com/pywharf/pywharf).\n\nThe index of the private PyPi is located [here](https://astaralabs.github.io/astaralabs-pypi-pkg-repo/).\n\nTo publish a package in that repository you will need a GitHub [PAT](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens) as credentials.\n\nFirst you have to start the [Pywharf](https://github.com/pywharf/pywharf) server:\n\n```bash\ndocker run --rm -v ./pywharf-root:/pywharf-root -p 8888:8888 pywharf/pywharf:0.2.3 server\ncurl -d $'config=[astaralabs-pypi-pkg-repo]\\ntype = \"github\"\\nowner = \"astaralabs\"\\nrepo = \"astaralabs-pypi-pkg-repo\"\\nbranch = \"main\"&admin_secret=[astaralabs-pypi-pkg-repo]\\ntype = \"github\"\\nraw = \"<YOUR-GITHUB-PAT>\"' -X POST http://localhost:8888/initialize/\n```\n\n```bash\n# config Poetry to use our own PyPi\npoetry config repositories.astaralabs-pypi http://localhost:8888/simple/\n\n# publish the package (this assumes you already built the package with `poetry build -f wheel`)\npoetry publish --repository astaralabs-pypi --username astaralabs-pypi-pkg-repo --password <YOUR-GITHUB-PAT> --skip-existing\n\n```\n"
keywords = ""
classifiers = "Programming Language :: Python :: 3"
download_url = ""
comment = ""
md5_digest = "8f82bc42d7e98ed34f97b54087cf617a"
sha256_digest = "434ccf3cce6997edd2e13985438439e2e34233cc447c0be9ecebe879890698b8"
blake2_256_digest = "6c2d3c8233443bf4d0d4066ac9b42f69b343c09b88a6b8bd049b0b563cc930f4"
requires_dist = "shapely (>=2.0.1,<3.0.0)"
requires_python = ">=3.10,<3.13"
description_content_type = "text/markdown"
":action" = "file_upload"
protocol_version = "1"
distrib = "beehive"
sha256 = "434ccf3cce6997edd2e13985438439e2e34233cc447c0be9ecebe879890698b8"
[[pkgs]]
type = "github"
distrib = "beehive"
package = "beehive-0.1.0-py3-none-any"
ext = "whl"
sha256 = "ebd87f191ac884e3108c49d77720194d5ded698c0a0555d2e6510170679f9281"
url = "https://api.github.com/repos/astaralabs/astaralabs-pypi-pkg-repo/releases/assets/119566534"

[pkgs.meta]
name = "beehive"
version = "0.1.0"
filetype = "bdist_wheel"
pyversion = "py3"
metadata_version = "2.1"
summary = ""
home_page = ""
author = "astara labs"
author_email = "dev@astaralabs.com"
maintainer = ""
maintainer_email = ""
license = ""
description = "# beehive\n\nBeehive is a library aimed at characterizing a territory with indicators. It works by dividing a territory defined by a polygon into a set of hexagons (with the [H3 hexagonal grid](https://h3geo.org/) as the base), then computing each of the indicators for each of the hexagons.\n\nIt includes tools to compute similarities between different hexagons within the territory and create distance matrix of them.\n\nTools to export the territory and the characterized hexagons to GeoJSON are also included.\n\n## Key concepts\n\nA **Territory** can be any land area defined by one or more polygons. It can be of any size.\n\nA Territory has a tessellation, which is a complete covering of it formed of **Hexagons**. Each Hexagon is defined by its [H3 index](https://h3geo.org/docs/library/terminology) (a unique unsigned 64 bit integer, represented as a hexadecimal string) but has also a `geometry` property defined by the [Shapely Polygon](https://shapely.readthedocs.io/en/stable/reference/shapely.Polygon.html#shapely.Polygon) representing its coordinates.\n\nThe size (called resolution) of the hexagons can be specified from 0 (bigger hexagons) to 15 (smaller hexagons). For a table comparing average hexagon areas for each resolution, check [H3 documentation](https://h3geo.org/docs/core-library/restable/#average-area-in-km2).\n\nWhen creating a territory, some **Indicators** are usually defined. They will be computed for each of the hexagons in the tessellation, and thus an Hexagon object will have a set of Indicators that define _how_ the Hexagon looks like, or characterizes it.\n\nAn Indicator can be anything that defines the land: from the average temperature or precipitations, to the surface of green zones, forests, or the length of the streets within it.\n\nThe library currently includes the following set of pre-defined indicators:\n\n- building_area: percentage of area which is covered by buildings of any kind. The data is obtained from OSM.\n- park_area: percentage of area which is covered by parks. Data obtained from OSM.\n- road_density: total sum of road lanes, in meters, inside the hexagon, divided by total area in squared meters of the hexagon. Data is also obtained from OSM.\n- precipitation_sum: total sum of precipitations (rain or snow) in the last year, measured in mm. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- rain_sum: total sum if rain precipitations in the last year, measured in mm. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- snowfall_sum: total sum of snow precipitations in the last year, measured in mm. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- temperature_2m_max: mean of the maximum daily temperatures at 2m above the ground in the last year, measured in Celsius. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- temperature_2m_min: mean of the minimum daily temperatures at 2m above the ground in the last year, measured in Celsius. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- temperature_2m_mean: mean of the mean daily temperatures at 2m above the ground in the last year, measured in Celsius. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- winddirection_10m_dominant: mean of the dominant daily wind directions, measured at 10 meters above the ground in the last year. Measured in °. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- windgusts_10_max: mean of the maximum wind gusts each day, measured at 10 meters above the ground, in km/h, in the last year. The data is obtained from [Open Meteo](https://open-meteo.com/)\n- windspeed_10_max: mean of the maximum wind speed each day, measured at 10 meters above the ground, in km/h, in the last year. The data is obtained from [Open Meteo](https://open-meteo.com/)\n\nIt is possible to use user-defined indicators. Any function that takes a shapely `Polygon` and returns an `Indicator` instance can be used.\n\n## Usage\n\nCreating a territory from a GeoJSON Polygon Feature.\n\n```Python\nfrom shapely.geometry import shape\nfrom beehive.territory import create_territory\n\nterritory_geojson = {\n    \"type\": \"Feature\",\n    \"properties\": {\n        \"place_id\": 307814314,\n        \"osm_type\": \"relation\",\n        \"osm_id\": 349469,\n        \"display_name\": \"Usera, Madrid, Comunidad de Madrid, España\"\n    },\n    \"bbox\": [-3.7208913, 40.3614413, -3.6817178, 40.395234],\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [\n                [-3.7208913, 40.3655479],\n               ...\n            ]\n        ]\n    }\n}\n\npolygon = shape(territory_geojson[\"geometry\"])\nterritory = create_territory(\n    name=\"Usera, Madrid\",\n    polygon=polygon,\n    indicators=[\"road_density\", \"building_area\", \"park_area\", \"precipitation_sum\"],\n    hex_resolution=8,\n)\n```\n\nCalculate the distance correlation matrix for each Hexagon:\n\n```Python\nfrom beehive.distance import calculate_matrix\n\nmatrix = calculate_matrix(territory.tessellation, metric=\"correlation\")\n```\n\nUsing custom indicators.\n\n```Python\nfrom beehive.model import Polygon, Indicator\nimport random\n\n# The model.Polygon is just a Shapely Polygon re-exported from our module\n\ndef my_random_indicator(polygon: Polygon) -> Indicator:\n    return Indicator(type=\"rand\", name=\"Random\", unit=\"none\", value=random.random())\n\nterritory = create_territory(\n    name=\"Usera, Madrid\",\n    polygon=polygon,\n    custom_indicators=[my_random_indicator],\n    hex_resolution=8,\n)\n```\n\n## API\n\nThe following modules are defined in the package\n\n### beehive.model\n\nIncludes classes for main concepts like Territory, Hexagon or Indicator.\n\n#### Indicator\n\nProperties:\n\n- _type_: `str`. type defining the indicator. E.g. road_density.\n- _name_: `str`. readable name of the indicator. E.g. Road length.\n- _unit_: `str`. unit in which the indicator is measured. E.g. m (meters).\n- _value_: `float`. the value of the indicator.\n\nMethods:\n\n- to_dict() -> dict: returns dict representation of the indicator properties.\n\n#### Hexagon\n\nProperties:\n\n- _id_: `str`. Unique id defining the Hexagon. In fact, a H3 index determining the exact Hexagon in the H3 hex grid.\n- _geometry_: `shapely.Polygon`. Polygon defining the boundaries of the hexagon.\n- _indicators_: `set[Indicator]`. Set containing all the Indicators defined for the Hexagon.\n- _ordered_indicators_: `list[Indicator]`. The previous indicators, but as a list and sorted alphabetically by their `type`.\n\nMethods:\n\n- `to_geojson_dict() -> dict`: returns a dict with the GeoJSON representation of the Hexagon. Indicators, and id are included as `properties`.\n\n#### Territory\n\nProperties:\n\n- _id_: `str`. Unique id asigned to the territory.\n- _name_: `str`. Name of the territory. E.g. \"Norte de Madrid\".\n- _geometry_: `shapely.Polygon`. Polygon defining the boundaries of the hexagon.\n- _tessellation_: `list[Hexagon]`. List of Hexagons covering the territory geometry.\n\nMethods:\n\n- `to_geojson_dict() -> dict`: returns a dict with the GeoJSON representation of the Territory. Name and id are included as `properties`.\n\n- `tessellation_to_geojson_dict() -> dict`: returns a dict with the GeoJSON FeatureCollection of the Hexagons that form the territory tessellation.\n\n### beehive.territory\n\nIncludes functions to create both single Hexagon or Territory with an hexagonal tessellation, with specified Indicators.\n\n- `create_hexagon(id: str, polygon: shapely.Polygon, indicators: list[str]) -> model.Hexagon`: creates an Hexagon object for the given polygon and with the specified indicators.\n- `create_territory(name: str, polygon: shapely.Polygon, indicators: list[str], hex_resolution: int = 10) -> model.Territory`: creates the hexagonal tessellation with the specified resolution, then computes all the indicators for each hexagon, and creates the territory holding them, and returns it.\n\n### beehive.distance\n\nFunctions to compute distance between Hexagons for a territory, based on the characterization given by their indicators.\n\n- `calculate_matrix(hexagons: list[model.Hexagon], metric= \"correlation\") -> list[float]`: returns the condensed distance matrix of the given hexagons, which is an 1-array representation of the matrix distance. As specified by the [Scipy documentation](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html#scipy.spatial.distance.pdist), \"For each i and j (where i< j < m), where m is the number of original observations. The metric dist(u=X[i], v=X[j]) is computed and stored in entry m _ i + j - ((i + 2) _ (i + 1)) / 2\".\n\n## TODO / Roadmap\n\n- Add more indicators.\n\n## Development\n\n### Dependencies\n\nYou will need to have Poetry [installed](https://python-poetry.org/docs/#installation).\n\nThen, to install all the dependencies, run `poetry install`.\n\n### Testing, linting, formatting...\n\nRun the tests with `poetry run pytest`.\n\nFor running the linter with autofixing: `poetry run ruff .`. (Ruff configuration is located in [pyproject.toml](pyproject.toml)).\n\nBlack can be used to format the files with `poetry run black .` (Black configuration is located in [pyproject.toml](pyproject.toml)).\n\n### Releases\n\nAs of today, GitHub Package Repository does not support Python packages. For that reason, we have created a [private PyPi repository](https://github.com/astaralabs/astaralabs-pypi-pkg-repo) on top of GitHub Pages using [this tool](https://github.com/pywharf/pywharf).\n\nThe index of the private PyPi is located [here](https://astaralabs.github.io/astaralabs-pypi-pkg-repo/).\n\nTo publish a package in that repository you will need a GitHub [PAT](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens) as credentials.\n\nFirst you have to start the [Pywharf](https://github.com/pywharf/pywharf) server:\n\n```bash\ndocker run --rm -v ./pywharf-root:/pywharf-root -p 8888:8888 pywharf/pywharf:0.2.3 server\ncurl -d $'config=[astaralabs-pypi-pkg-repo]\\ntype = \"github\"\\nowner = \"astaralabs\"\\nrepo = \"astaralabs-pypi-pkg-repo\"\\nbranch = \"main\"&admin_secret=[astaralabs-pypi-pkg-repo]\\ntype = \"github\"\\nraw = \"<YOUR-GITHUB-PAT>\"' -X POST http://localhost:8888/initialize/\n```\n\n```bash\n# config Poetry to use our own PyPi\npoetry config repositories.astaralabs-pypi http://localhost:8888/simple/\n\n# publish the package (this assumes you already built the package with `poetry build -f wheel`)\npoetry publish --repository astaralabs-pypi --username astaralabs-pypi-pkg-repo --password <YOUR-GITHUB-PAT> --skip-existing\n\n```\n\nAnd, to install the package in another Python project:\n\n```bash\n# set our PyPi repository as a source in Poetry\npoetry source add --secondary astaralabs-pypi https://astaralabs.github.io/astaralabs-pypi-pkg-repo/\n\n## If using poetry 1.5 or above\n# poetry source add --priority=explicit astaralabs-pypi https://astaralabs.github.io/astaralabs-pypi-pkg-repo/\n\npoetry add --source=astaralabs-pypi beehive\n```\n"
keywords = ""
classifiers = "Programming Language :: Python :: 3"
download_url = ""
comment = ""
md5_digest = "8dc287c7d979d165edb3d1ab109e130a"
sha256_digest = "ebd87f191ac884e3108c49d77720194d5ded698c0a0555d2e6510170679f9281"
blake2_256_digest = "d072014c99c5f9dbe1bb7f4bcafcf85c531da4c7a874d463598d776342508833"
requires_dist = "shapely (>=2.0.1,<3.0.0)"
requires_python = ">=3.10,<3.13"
description_content_type = "text/markdown"
":action" = "file_upload"
protocol_version = "1"
distrib = "beehive"
sha256 = "ebd87f191ac884e3108c49d77720194d5ded698c0a0555d2e6510170679f9281"
[[pkgs]]
type = "github"
distrib = "astaraplay"
package = "astaraplay-0.1.0-py3-none-any"
ext = "whl"
sha256 = "bb8c65e2ea454308681a61252de651d1e1f1f87fc72c638c496ebc920c164a92"
url = "https://api.github.com/repos/astaralabs/astaralabs-pypi-pkg-repo/releases/assets/115368415"

[pkgs.meta]
name = "astaraplay"
version = "0.1.0"
filetype = "bdist_wheel"
pyversion = "py3"
metadata_version = "2.1"
summary = ""
home_page = ""
author = "astara labs"
author_email = "dev@astaralabs.com"
maintainer = ""
maintainer_email = ""
license = ""
description = "# astaraplay\n\nPython library to interact with [astaraplay](https://astaraplay.com/) API.\nDocumentation of the API can be found [here](https://api.traffic-restrictions.astaralabs.com/docs).\n\n## Usage\n\nTo use this library, you will need credentials to access the astaraplay API. The API uses an HMAC authentication schema which is handled by this library, so you will only need to provide the `credential_id` and `secret` for your account.\n\nThen, just create an instance of the `Astaraplay` class and use it:\n\n```python\nfrom astaraplay import Astaraplay\n\nastaraplay = Astaraplay(credential_id=\"your-credential-id\", secret=\"your-secret\")\n\nresponse = astaraplay.request(method=\"GET\", url=\"/vehicle-info/1223GJP\")\n\nresponse.status_code\n# 200\nreponse.json\n# {'license_plate': '1223GJP', 'sticker': 'c', 'vehicle_type': 'vehiculo', 'license_registration_date': {'year': 2008, 'month': 11}, 'category': 'M1'}\n\n```\n\n## Development\n\n### Dependencies\n\nYou will need to have Poetry [installed](https://python-poetry.org/docs/#installation).\n\nThen, to install all the dependencies, run `poetry install`.\n\n### Testing\n\nThe tests interact with the actual astaraplay API, so you need credentials to call it.\nCreate a `.env` file from the provided `.env-template` one and fill it with the credentials (the credentials for lib testing are stored in the astaraplay DB).\n\nThe test suite will automatically load them as environment variables so you won't need to do any further steps.\n\nFinally, run the tests with `poetry run pytest`.\n\n### Linting, formatting...\n\nFor running the linter with autofixing: `poetry run ruff .`. (Ruff configuration is located in [pyproject.toml](pyproject.toml)).\n\nBlack can be used to format the files with `poetry run black .` (Black configuration is located in [pyproject.toml](pyproject.toml)).\n\n### Releases\n\nAs of today, GitHub Package Repository does not support Python packages. For that reason, we have created a [private PyPi repository]() on top of GitHub Pages using [this tool](https://github.com/pywharf/pywharf).\n\nThe index of the private PyPi is located [here](https://astaralabs.github.io/astaralabs-pypi-pkg-repo/).\n\nTo publish a package in that repository you will need a GitHub [PAT](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens) as credentials.\n\nFirst you have to start the [Pywharf](https://github.com/pywharf/pywharf) server:\n\n```bash\ndocker run --rm -v ./pywharf-root:/pywharf-root -p 8888:8888 pywharf/pywharf:0.2.3 server\ncurl -d $'config=[astaralabs-pypi-pkg-repo]\\ntype = \"github\"\\nowner = \"astaralabs\"\\nrepo = \"astaralabs-pypi-pkg-repo\"\\nbranch = \"main\"&admin_secret=[astaralabs-pypi-pkg-repo]\\ntype = \"github\"\\nraw = \"<YOUR-GITHUB-PAT>\"' -X POST http://localhost:8888/initialize/\n```\n\n```bash\n# config Poetry to use our own PyPi\npoetry config repositories.astaralabs-pypi http://localhost:8888/simple/\n\n# publish the package (this assumes you already built the package with `poetry build -f wheel`)\npoetry publish --repository astaralabs-pypi --username astaralabs-pypi-pkg-repo --password <YOUR-GITHUB-PAT> --skip-existing\n\n```\n\nAnd, to install the package in another Python project:\n\n```bash\n# set our PyPi repository as a source in Poetry\npoetry source add --secondary astaralabs-pypi https://astaralabs.github.io/astaralabs-pypi-pkg-repo/\n\n## If using poetry 1.5 or above\n# poetry source add --priority=explicit astaralabs-pypi https://astaralabs.github.io/astaralabs-pypi-pkg-repo/\n\npoetry add --source=astaralabs-pypi astaraplay\n```\n"
keywords = ""
classifiers = "Programming Language :: Python :: 3"
download_url = ""
comment = ""
md5_digest = "a8c08778b0ca2017de44f8131b83ae8a"
sha256_digest = "bb8c65e2ea454308681a61252de651d1e1f1f87fc72c638c496ebc920c164a92"
blake2_256_digest = "09be759f40f4c0aa008c5ea7f5b2e7c1e3871599cb7c9cea7ff7c1a8d4e05f44"
requires_dist = "httpx (>=0.24.1,<0.25.0)"
requires_python = ">=3.10,<4.0"
description_content_type = "text/markdown"
":action" = "file_upload"
protocol_version = "1"
distrib = "astaraplay"
sha256 = "bb8c65e2ea454308681a61252de651d1e1f1f87fc72c638c496ebc920c164a92"
[[pkgs]]
type = "github"
distrib = "python-lib-template"
package = "python_lib_template-0.1.0-py3-none-any"
ext = "whl"
sha256 = "1cff00579d02108a3eee58d8a59fb113fdd4bb6906945bc9ec1b40f67c1cda00"
url = "https://api.github.com/repos/astaralabs/astaralabs-pypi-pkg-repo/releases/assets/114522460"

[pkgs.meta]
name = "python-lib-template"
version = "0.1.0"
filetype = "bdist_wheel"
pyversion = "py3"
metadata_version = "2.1"
summary = ""
home_page = ""
author = "alejandrodob"
author_email = "alejandro.dominguez.b@astara.com"
maintainer = ""
maintainer_email = ""
license = ""
description = "# python-lib-template\n\nA template for Python libraries\n\n## Included tools\n\n- [Poetry](https://python-poetry.org/) for handling the project dependencies, building and (in the future) publishing the package.\n- [MyPy](https://www.mypy-lang.org/) for type checking.\n- [Ruff](https://beta.ruff.rs/docs/) for linting (configured to auto fix whenever possible).\n- [Black](https://black.readthedocs.io/en/stable/index.html) for autoformatting.\n- [Pytest](https://pytest.org/) for testing.\n\n## Usage\n\nAfter using the template for a new library repository, rename the package folder `python_lib_template` to your library name and do a global search of the string \"python_lib_template\" and replace it for your library name too.\n\n## Dependencies\n\nYou will need to have Poetry [installed](https://python-poetry.org/docs/#installation).\n\nThen, to install all the dependencies, run `poetry install`.\n\n## Testing, linting, formatting...\n\nRun the tests with `poetry run pytest`.\n\nFor running the linter with autofixing: `poetry run ruff .`. (Ruff configuration is located in [pyproject.toml](pyproject.toml)).\n\nBlack can be used to format the files with `poetry run black .` (Black configuration is located in [pyproject.toml](pyproject.toml)).\n\n## Releases\n\nAs of today, GitHub Package Repository does not support Python packages. For that reason, we will install the package directly from GitHub, as explained [here](https://pip.pypa.io/en/stable/topics/vcs-support/).\n"
keywords = ""
classifiers = "Programming Language :: Python :: 3"
download_url = ""
comment = ""
md5_digest = "a98271448ff8935e1f18423c4ac945d8"
sha256_digest = "1cff00579d02108a3eee58d8a59fb113fdd4bb6906945bc9ec1b40f67c1cda00"
blake2_256_digest = "d1206ec15f63e8e37a7e3d142c5da31cd8844c8e74dcf4975e9809cf6b6e5f03"
requires_python = ">=3.10,<4.0"
description_content_type = "text/markdown"
":action" = "file_upload"
protocol_version = "1"
distrib = "python-lib-template"
sha256 = "1cff00579d02108a3eee58d8a59fb113fdd4bb6906945bc9ec1b40f67c1cda00"
